\section{Radio Access Network}
\label{sec:access}

In this section, we detail the functions executed by the network equipment to enable data transmission. The network equipment needs to acquire \acs{CSI} and manage resources accordingly to cope with the incoming application traffic and fulfil service requirements. Firstly, we go over important considerations and assumptions, namely regarding multi-layer transmissions, concentrating on the \ac{DL}, among other miscellaneous but relevant matters. Then we list the steps required to simulate a \ac{TTI} and all processing associated with making the right choices when transmitting and receiving. We summarise these steps with a flowchart and proceed to detail each one.

Firstly, we opt for a \ac{GoB}-based beamforming approach. With the growing number of antennas at the receivers, full channel knowledge is practically unobtainable, and we need to resort to more overhead-efficient approaches. 

Secondly, we address the considerations regarding multi-layer transmission. To reiterate, the difference between single-layer and multi-layer operation is the number of independent streams transmitted per \ac{UE}. And to transmit independent streams or layers, there must be some orthogonality mechanism that renders such layers independent. The orthogonality domain we are concerned with is orthogonality in space. However, by opting \ac{GoB}-based beamforming although we save in overhead, we loose considerably in transmission flexibility. Free-format beamforming would allow us to send independent layers in the same direction, only focusing different antennas at the reception. But using a \ac{GoB} we do not have enough beams to do that, instead we have to resort to completely different propagation paths, with paths beyond the first not being the \ac{LoS}. This would not yield insignificant improvements. 

Another option would be to resort to polarisation orthogonality. Instead of using all antenna elements to perform a transmission, we may use the antennas oriented in a given direction to send one layer and the elements oriented perpendicularly to send another. Note that the same beam in the GoB can be used for the different polarisations when they are to be sent over the same path. However, the moments in time where inter-polarisation interference is small, e.g. less than 20 dB, are rare. In other words, often antennas with a given orientation at the receiver get signal from both polarisations at the transmitter. Thus, it would require considerably more complicated interference estimations algorithms to do multi-layer transmissions polarisation-based. This is why we opt for single-layer transmission using all antennas both in the \ac{TX} and in the \ac{RX}. Nevertheless, the vast majority of modelling in this section is agnostic to the number of layers.

Thirdly, although in Section \ref{sec:sxr_meeting_modelling} we modelled the location of all \acsp{UE} in the system and application traffic for \acs{UL} and \acs{DL}, for conciseness in this section we describe the model for \acs{DL} transmission procedure and thus we do not consider cameras. In the \acs{DL}, he number of UEs $N_{ue}$ equal to the number of physical users $N_{phy}$. Moreover, we consider a single-BS with a one or more antenna panels.

In essence, we need to list all procedures that can happen in a \acs{TTI}. Some may not happen every \acs{TTI} and we need to state in what circumstances they do happen. Figure \ref{fig:flowchart_sls} shows a flowchart of the main steps required to simulate a (\acs{DL}) \acs{TTI}.

\image{Methodology/Radio Access/flowchart.png}{Flowchart for of simulation steps for each TTI.}{fig:flowchart_sls}{.48}

Several verifications are made to decide whether some procedures should take place. The first is to identify the nature of the current \acs{TTI} - UL and DL TTIs have different steps. The second is checking whether CSI should be updated. Thirdly, it is to verify whether the current user scheduling information for that TTI is to be updated. Only after those verifications and respective procedures, the transmissions scheduled for the present TTI are processed. 

We start by assessing the nature of the TTI. It depends on the slot-structure and TDD split.

\subsection*{TDD Split and Slot Format}

We recognise two options. The first is to use self-contained slots, at a cost of about $2/14 \approx 14\%$ lower bit rate since 2 out of 14 symbols are used for guard and control, but having the benefit of feedback about block errors in the same TTI, thus allowing triggering retransmissions of the lost information the next TTI. This way the likelihood of packet dropping due to transgressions of time constrains is reduced since latency is reduced, leading to more opportunities to transmit the data on time. The second is simpler and more throughput-efficient, at the cost of latency performance. It consists on using slots that only have \ac{DL}/\ac{UL} symbols, respectively, and we ignore the guard time in the transition slot.

Therefore our definition of \ac{UL}-\ac{DL} split, or \ac{TDD} split depends on the option. We define $s_{TDD}$ as the ratio between UL and DL slots. We represent this ratio as $N^{DL}_{slots} : N^{UL}_{slots}$, e.g. 4:1, meaning that for each UL slot there are 4 DL slots. The slot structure is fully defined by the number of slots in a transmission period $N^{TDD}_{slots}$.

In order to optionally change between both options, we introduce a transport block acknowledgement delay $\tau_{ACK}$ (in TTIs)  and a slot efficiency $\eta_{slot}$. The acknowledgement delay is the number of TTIs before the transmitter receives the acknowledgement, thus $\tau_{ACK} + 1$ is the number of TTIs until the erroneous transport block can be transmitted again. With self-contained slots, $\tau_{ACK} = 0$. Without self-contained slots it depends on the $s_{TDD}$.

The slot efficiency $\eta_{slot} = 0.86$ in the example of self-contained slots where 14\% of symbols are not used for data, and $\eta_{slot} = 0$ in the DL/UL heavy slots. It is applied to the instantaneous throughput $R$ as $R_{modified} = R \eta_{slot}$

\begin{comment}
Equations \eqref{eq:tdd_split} and \eqref{eq:slot_per}.

\begin{align}
    s_\text{TDD} &= N^\text{DL}_\text{slots} \ / \ N^\text{UL}_\text{slots} \label{eq:tdd_split} \\
    P_\text{slot} &= N^\text{DL}_\text{slots} + N^\text{UL}_\text{slots} \label{eq:slot_per}
\end{align}
\end{comment}

As mentioned, we solely present, and posteriorly evaluate, modelling for DL TTIs. Thus after making the distinction between TTIs, the next step is to update the CSI information based on our beamforming strategy. Therefore, let us first state how the \ac{GoB} is created.

\subsection*{Grid of Beams}
\label{sec:GoB}

To create a GoB we need to know which directions to steer the beam. The beam-steering directions are all possible combinations of values in the azimuthal and elevation angular domains, relative to the antenna boresight (direction perpendicular to the plane the antenna array is inserted). And to create a beam grid in one such domain, one simple way is to use the resolution and the values of the extremes. We define in Equation \eqref{eq:inter_func} an interpolation function to perform the operation of creating a set of values from $a$ to $b$, given $b > a$, with intervals of resolution $r$.


\begin{equation} \label{eq:inter_func}
    F_I(a, b, r) = \left\{a + i \times r \  \forall \ i \in \mathbb{N}_0: i \times r \leq b-a \right\}
\end{equation}

This way, we define in the azimuthal angular domain as $\mathcal{A}_\phi = F_I(a_\phi, b_\phi, r_\phi)$ and the elevation angular domain as $\mathcal{A}_\theta = F_I(a_\theta, b_\theta, r_\theta)$. For instance, if the antenna is positioned in the centre of the room, on the ceiling, pointing downwards, then the most logical approach is a symmetric approach because in that position the coverage of the room would be uniform since we consider our room with equal length and width - room and user behaviour is modelled in Section \ref{sec:sxr_meeting_modelling}. More concretely, the GoB should cover all positions the UEs may potentially be. Thus, given the position and movement of the users in relation to the size of the room described in the example of Section \ref{sec:ue_placement}, choosing the lower limits to $a_\phi = a_\theta = -60\text{\textdegree}$ and the upper limits to $b_\phi = b_\theta = 60\text{\textdegree}$ covers all possible UE positions.

The resolutions should depend on the array size. To create a pseudo-non-interfering GoB, where the maximum of the main lobe of one beam points at the a minimum of an adjacent beam, the resolution should be roughly half the \ac{FNBW}. It is `pseudo-non-interfering' because the \ac{FNBW} varies with the direction at which the beam is steered, which causes the maximums to not align perfectly with the nulls. This effect is unnoticeable in adjacent beams, and gets more noticeable the more far apart beams are from each other. So, this method is a simplistic yet effective approach to minimise the interference between beams, but it does not eliminate this interference. 

Thus, the possible directions are defined as a cartesian product between the azimuthal and elevation domains, shown in Equation \eqref{eq:dir}.

\begin{equation} \label{eq:dir}
    \mathcal{D} = \mathcal{A}_\phi \times \mathcal{A}_\theta = \left\{(\phi, \theta) : \ \phi \in \mathcal{A}_\phi , \ \theta \in \mathcal{A}_\theta\right\}
\end{equation}


Having the directions, we need the precoder that will construct a beam pointing in that direction. In Equation \eqref{eq:prec_func} we define the $M$ by $N$ beamforming matrix $\bm{W}_{\phi, \theta}$ that contains the relative amplitudes and phases that are applied to the signal of each antenna element of an $M$ by $N$ planar array, obtaining as a result a beam directed to $\phi$ degrees on the horizontal plane and $\theta$ degrees on the vertical plane. Note that such planes depend on the orientation of the array and the angles $\phi$ and $\theta$ are null in the interception of both planes, corresponding to the direction orthogonal to the array plane. Appendix \ref{sec:beam_steering} holds a complete derivation.


\begin{align} \label{eq:prec_func}
    \bm{W}_{\phi, \theta}= 
    \begin{bmatrix}
        1 & u_2 & \dots & u_2^{(N-1)}\\
        u_1 & u_1 u_1 & \dots & u_1 u_2^{(N-1)}\\
        \vdots & \vdots & \ddots & \vdots\\
        u_1^{(M-1)} & u_1^{(M-1)} u_2 & \dots & u_1^{(M-1)} u_2^{(N-1)}
    \end{bmatrix}, \ \text{with} \
    \begin{cases}
        u_1 = e^{-j \pi \sin(\phi) \sin(\theta)} \\
        u_2 = e^{-j \pi \cos(\phi) \sin(\theta)}
    \end{cases}
\end{align}


Subsequently, to obtain every precoder in the GoB we need to build a precoding matrix for each direction in $\mathcal{D}$. Let us define in Equation \eqref{eq:W} the set $\mathcal{W}$ containing all precoders $\bm{W}_{\phi, \theta}$ in the GoB, formed for an $M$ by $N$ \ac{URA}. 

\begin{equation} \label{eq:W}
    \mathcal{W}^\text{GoB} = \left\{ \bm{W}_{\phi, \theta} : (\phi, \theta) \in \mathcal{D}\right\}
\end{equation}

As a last step, we vectorise the matrix $\bm{W}_{\phi, \theta}$ into a vector $\bm{w}_{\phi, \theta}$, to facilitate its usage. This process is exactly the same as stacking the columns of $\bm{W}_{\phi, \theta}$.

Figure \ref{fig:GoB} illustrates the result of a cut at zero degrees elevation on beams of two grids. The two grids are built for square antenna arrays, with 16 and 1024 elements, respectively, left and right sides of the figure, hence the noticeably different directivity. Using the 3GPP-defined elements in \cite{3gpp_antennas}, the maximum directivities are 20 dBi and 38 dBi, respectively, for the 16-element array and for the 1024-element array. Furthermore, since the resolutions were purposely set to match half of the \ac{FNBW}, the grid on the left spans 120\textdegree \ of angular domain, from -60\textdegree \ to 60\textdegree, with steps of 30\textdegree, while the grid on the right does so with a resolution of 4\textdegree. In total, this equates to 25 distinct beams of the small array and 961 beams in the larger array.

\image{GoB/gob_paper_final_cut.png}{GoB azimuth cuts for 4 by 4 (left) and a 32 by 32 (right) antenna element array.}{fig:GoB}{.55}



\subsection{Channel State Information}

CSI updates happen every $N^{CSI}_{slots}$ slots or \acsp{TTI}. Not all TTIs have CSI updates because the channel does not change enough to be worth updating that frequently, and due to prohibitive overheads since reference signals are sent in place of data. 

The overheads associated with different \ac{CSI} feedback schemes is not modelled. The overhead would depend on the type and quality of said measurements, thus we simply define a CSI-slot efficiency $\eta_{CSI}$ meant to reduce the bit rate of CSI slots.

CSI is required for operation of two important mechanisms. First, to direct and receive signals optimally, in accordance with the paths where attenuation is lower. As such, it is used to update matching beamformers at the transmitter and receiver, or beam pairs. Second, to assess received power and interference, which are crucial to estimate channel quality, which is then used to, e.g. determine which MCS to use.

Let us address the beam pair establishment first. Our formulation holds beam correspondence \cite{beam_management}, this means the beam computed for the transmitting are used for receiving as well. Therefore we refer to weights vectors as beamformers, instead of the direction-specific nomenclatures like precoder or combiner.

\subsubsection*{Beam pairs Update}

To update the best beam pairs between UEs and BS panels, the BS should transmit $N_{CSI}$ CSI-RSs precoded in GoB beams and the UE reports how well it received each RS. However, this would require a mechanism for the BS to identify, based on previous channel measurements, which beams are more likely to best serve the UE. As such, instead we check all beams in the \ac{GoB} to assess which best suit the channel. Furthermore, we keep received power information about $N_{CSI}$ of them, which is useful for future SINR estimations.

The best beam pairs are chosen to maximise the channel gain achieved from performing a transmission with a given GoB beam, with a best effort reception using \acs{MRC}. Therefore, for a link between UE $u$ and BS panel $b$, the beamformer on the BS side $\bm{w}^{BS}_{bu}$ is always a $N_{ant}^{BS}\times 1$ beam-steering vector from the GoB, i.e. $\bm{w}^{BS}_{bu} \in \mathcal{W}^{GoB}_b$. The UE-side beamformer $\bm{w}^{UE}_{bu}$ is always the \ac{MR} beamformer that fits the BS beamformer used over the $N_{ant}^{UE} \times N_{ant}^{BS}$ channel $\bm{H}_{bu}$. As such, the received signal in each of the $N_{ant}^{UE}$ UE antennas is $\bm{H}_{bu} \cdot \bm{w}^{BS}_{bu}$. Here, $N_{ant}$ refers to the number of single-polarised antenna elements. The computation of the UE-side beamformer is given in Equation \ref{eq:GoB_choice_ue}, from using Equation \ref{eq:mr}. 


\begin{equation} \label{eq:GoB_choice_ue}
    \bm{w}^{UE}_{bu} = \frac{\left(\bm{H}_{bu} \cdot \bm{w}^{BS}_{bu}\right)^H}{\left|\bm{H}_{bu} \cdot \bm{w}^{BS}_{bu}\right|}
\end{equation}


When $\bm{w}^{UE}$ is a MR beamformer, the channel gain under transmit and receive beamforming is a real number. Therefore, to choose the $\bm{w}$ that achieves the highest gain, we simply have to choose $\bm{w}$ that results in highest norm of its internal product with the channel. This shortcut is represented in Equation \eqref{eq:GoB_choice}. In essence, this means that because we are computing the UE-side beamformer already taking into account the transmit-side beamformer, to maximise the norm of the received signal it is sufficient to choose the appropriately the transmit-side beamformer. 

\begin{equation} \label{eq:GoB_choice}
    \bm{w}^{BS}_{bu} = \argmax_{\bm{w} \ \in \ \mathcal{W}^{GoB}_b} \left| \bm{w}^{UE}_{bu} \cdot \bm{H}_{bu} \cdot \bm{w} \right| = \argmax_{\bm{w} \ \in \ \mathcal{W}^{GoB}_b} \left| \bm{H}_{bu} \cdot \bm{w}\right|
\end{equation}

When $N_{CSI} > 1$, instead of the best beamformer, we save the $N_{CSI}$ best GoB beamformers. For sake of practicality, let us assume $N_{CSI} = 1$ for now on. Furthermore, beam pairs computed in this way profit from beam-reciprocity, i.e. the beams used for receiving can be used for transmitting as well. And doing this way, the received power is already present from Equation \eqref{eq:rx_pow_ue}, thus we only need to update the interference now.

\begin{equation} \label{eq:rx_pow_ue}
    P_{r, bu}^{UE} = P_{t, bu}^{BS} \left| \bm{w}^{UE}_{bu} \cdot \bm{H}_{bu} \cdot \bm{w}^{BS}_{bu} \right|^2 
\end{equation}


\subsubsection*{Interference Measurements Update}

To measure interference, the \ac{BS} should schedule an empty UE-specific \acs{RS} for interference measurements. It should result in measuring the power received by the interfering sources. The main drawback is the outdatedness of the measurement. It takes around 4 TTIs until the information is available since it needs to be sent, received, processed and fed back. Therefore, when the interference measurement is available, it refers to $\tau_\text{TTI}$ TTIs back, e.g. 4 TTIs ago. 

A major disadvantage of estimating the interference in this manner comes from the fact that the experienced interference is extremely dependent on current scheduling. If the scheduled UEs or beamformers in use change, then it is expected that a major change in the experienced interference takes place, thus possibly rendering the measurement completely invalid. We foresee precise interference estimation algorithms, perhaps driven by learning mechanisms, to be a future direction of work. We discuss this matter further in Section \ref{sec:future-work}. 


\subsection{User Scheduling}

Analogous to the CSI update procedure, the scheduling information is only updated every $N^{SCH}_{slots}$ TTIs. In a first stage, we renovate the scheduling information on which UEs are considered for scheduling and which BS panels are used for each UE. In essence, only UEs with non-empty buffers are examined to potentially be part of the scheduled list; and each UE is served by a single BS panel with the best beam pair to that UE. This constitutes the simplest panel selection scheme. 

The scheduling process then continues to estimate SINRs and achievable throughputs for each UE, to compute UE priorities, to make user co-scheduling decisions, assign powers for each transmission and derive MCS to be used. The SINR estimation step is presented first.

\subsubsection*{SINR Estimation}

The received powers for the best $N_{CSI}$ beams have been reported in the CSI acquisition step, as well as the interference levels computed from experienced interference from $\tau_{CSI}$ TTIs ago. Also, the channel gain can be derived directly knowing the transmit power that was used. Thus, we assume an equal distribution of the maximum transmit power at the BS $P_{t, max} ^ {BS}$ over the number of scheduled UEs with non-empty buffers. And the only missing piece in the SINR expression is the noise. 

We use wideband scheduling, i.e. allocating all available spectrum to every transmission, relying on spatial separation to prevent excessive interference. Therefore, assuming $B$ to be the system bandwidth, using thermal noise we get a noise power $P_N$ given by Equation \eqref{eq:noise}, with the Boltzmann constant $k_B = 1.380649 \times 10^{-23}$ J/K, the noise temperature $T$ and an upscaling with the receivers' noise figure $NF_r$. All hardware imperfections are abstracted by considering noise figures in the \acs{BS} and in the \acsp{UE}, respectively, $NF_{BS}$ and $NF_{UE}$, in dB.


\begin{equation} \label{eq:noise}
    P_N = k_B T B \times 10^{\frac{NF_r}{10}}
\end{equation}

To summarise, the expression used for SINR estimation uses the received power $P_s$ and total interference $I$ information from $\tau_{CSI}$ TTIs ago. Such information is used as shown in Equation \ref{eq:sinr_estimation} to compute an estimate of the SINR $\hat{SINR_{eff}}$.

\begin{equation} \label{eq:sinr_estimation}
    \hat{SINR_{eff}} = \frac{\hat{P}_s}{\hat{I} + P_N} 
\end{equation}

\subsubsection*{Instantaneous Throughput}

To compute the instantaneous throughput, we need to quantify the value of serving each user. Then we can weigh transmission options regarding fairness, maximum aggregated throughput, or likelihood of fulfilling latency constraints. It is also needed to calculate the estimated and realised bit rates.

The SINR is used to choose which CQI should be reported from the BLER curves represented in Figure \ref{fig:blercurves}, with equations in Appendix \ref{ap:blercurves}. The point at which each curve intercepts the BLER probability of 10\% is marked. The corresponding MCS choice consists on selecting the highest MCS that achieves a lower percentage of block errors than the \ac{BLER} target $BLER_0$.

\image{SLS/MCS_final_res300.png}{BLER curves for all MCSs. Simulated with Vienna Link-Level Simulator \cite{Vienna5GLLS}.}{fig:blercurves}{.37}


The selected MCS is then adjusted with the OLLA parameter as described ahead. The resultant MCS tells us the number of bits in a symbol $N_{bits}^{symb}$, which can be computed from the modulation order M, through $\log_2(M)$. To compute the bits per PRB we assume initially that all REs in a PBR are used for data, i.e. $N_{symb}^{PRB} = 168$, we multiply by $N_{bits}^{symb}$ and take into account the code rate $R_c$. In essence, Equation \eqref{eq:bit rate} computes the bit rate by dividing the number of bits transmitted in a PRB by the duration of that PRB, which corresponds to a slot duration $T_{slot, \mu}$, that depends on the numerology $\mu$.

\begin{equation} \label{eq:bit rate}
    R_b = \frac{N_{bits}^{symb} \times N_{symb}^{PRB} \times R_{c}}{T_{slot, \mu}} 
\end{equation}

To balance the excessively optimistic assumptions, like assuming all symbols are used for data, we adjust to the bit rate, namely due to signalling overheads and self-contained slots, respectively, by multiplying the efficiencies $\eta_{OH}$ and $\eta_{slot}$. Equation \eqref{eq:eff} has the final bit rate efficiency $\eta$. An estimation for the instantaneous throughput per TTI $R$ is $R = R_b \times \eta$.


\begin{equation} \label{eq:eff}
    \eta = \eta_{OH} \times \eta_{slot}
\end{equation}




\begin{comment}
Table \ref{tab:all_bit rates} is obtained by using Equation \eqref{eq:bit rate} for $\eta = 1$ for different numerologies.



\begin{table}[h]
    \centering
    \caption{Maximum achievable bit rates per PRB, for all numerologies.}
    \label{tab:all_bit rates}
    \begin{tabular}{cccc|c|c|c|c|}
    \cline{5-8}
                             &                        &                          &         & \multicolumn{4}{c|}{Bit Rates {[}kbps{]}} \\ \hline
    \multicolumn{1}{|c|}{CQI} &
      \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Bits per \\ Symbol\end{tabular}} &
      \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Code Rate \\ x 1024\end{tabular}} &
      \begin{tabular}[c]{@{}c@{}}bits \\ per PRB\end{tabular} &
      $\mu = 0$ &
      $\mu = 1$ &
      $\mu = 2$ &
      $\mu = 3$ \\ \hline
    \multicolumn{1}{|c|}{0}  & \multicolumn{2}{c|}{out of range}                 & 0       & 0        & 0        & 0        & 0        \\ \hline
    \multicolumn{1}{|c|}{1}  & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{78}  & 25.59   & 25.59    & 51.19    & 102.38   & 204.75   \\ \hline
    \multicolumn{1}{|c|}{2}  & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{193} & 63.33   & 63.33    & 126.66   & 253.31   & 506.63   \\ \hline
    \multicolumn{1}{|c|}{3}  & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{449} & 147.33  & 147.33   & 294.66   & 589.31   & 1178.63  \\ \hline
    \multicolumn{1}{|c|}{4}  & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{378} & 248.06  & 248.06   & 496.13   & 992.25   & 1984.50  \\ \hline
    \multicolumn{1}{|c|}{5}  & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{490} & 321.56  & 321.56   & 643.13   & 1286.25  & 2572.50  \\ \hline
    \multicolumn{1}{|c|}{6}  & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{616} & 404.25  & 404.25   & 808.50   & 1617.00  & 3234.00  \\ \hline
    \multicolumn{1}{|c|}{7}  & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{466} & 458.72  & 458.72   & 917.44   & 1834.88  & 3669.75  \\ \hline
    \multicolumn{1}{|c|}{8}  & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{567} & 558.14  & 558.14   & 1116.28  & 2232.56  & 4465.13  \\ \hline
    \multicolumn{1}{|c|}{9}  & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{666} & 655.59  & 655.59   & 1311.19  & 2622.38  & 5244.75  \\ \hline
    \multicolumn{1}{|c|}{10} & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{772} & 759.94  & 759.94   & 1519.88  & 3039.75  & 6079.50  \\ \hline
    \multicolumn{1}{|c|}{11} & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{873} & 859.36  & 859.36   & 1718.72  & 3437.44  & 6874.88  \\ \hline
    \multicolumn{1}{|c|}{12} & \multicolumn{1}{c|}{8} & \multicolumn{1}{c|}{711} & 933.19  & 933.19   & 1866.38  & 3732.75  & 7465.50  \\ \hline
    \multicolumn{1}{|c|}{13} & \multicolumn{1}{c|}{8} & \multicolumn{1}{c|}{797} & 1046.06 & 1046.06  & 2092.13  & 4184.25  & 8368.50  \\ \hline
    \multicolumn{1}{|c|}{14} & \multicolumn{1}{c|}{8} & \multicolumn{1}{c|}{885} & 1161.56 & 1161.56  & 2323.13  & 4646.25  & 9292.50  \\ \hline
    \multicolumn{1}{|c|}{15} & \multicolumn{1}{c|}{8} & \multicolumn{1}{c|}{948} & 1244.25 & 1244.25  & 2488.50  & 4977.00  & 9954.00  \\ \hline
    \end{tabular}
\end{table}
\end{comment}

\subsubsection*{Compute UE Priorities with Scheduler}

A scheduler task is to compute UE priorities $p$ according to a trade-off of resource sharing fairness, achieving the maximum instantaneous aggregated throughput, or attain the lower average latencies, to name a few. These priorities allow us to select UEs by order of importance according to the weighted trade-off relation we choose. 

The most common and widely used scheduler is the \ac{PF}, presented in Equation \eqref{eq:pf}. \ac{PF} takes the ratio between the estimated instantaneously attainable throughput $\hat{R}$ and average attained throughput $\overline{R}$ to balance immediate reward and fairness across users, for each TTI $t$. The average $\overline{R}$ is computed using exponential smoothing with a parameter $t_w$, according to Equation \eqref{eq:pf2}.

\begin{equation} \label{eq:pf}
    p(t) = \frac{\hat{R}(t)}{\overline{R(t)}}
\end{equation}

\begin{equation} \label{eq:pf2}
    \overline{R}(t) = \left( 1 - \frac{1}{t_w} \right) \overline{R} (t-1) + \frac{1}{t_w} R(t-1)
\end{equation}

As seen, PF does not consider latencies. Yet, for our case where each user has the same amount of data to receive (and each camera the same amount of data to transmit), the PF also levels latencies by weighting fairness, not leaving any user waiting for long. However, it may not perform as well as latency-aware alternatives.

Two latency-aware alternatives are \ac{EXP/PF} \cite{exp_algorithm} and \ac{M-LWDF} \cite{scheduler_performance_eval}. The latter is almost as simple as the PF, only weighting the \ac{HOL} latency as well. \ac{EXP/PF} is more complex and considers a maximum delay and increases priorities exponentially as latencies approach the limit. Both use the PF ratio described in Equation \eqref{eq:pf}. \ac{M-LWDF} outperforms \ac{EXP/PF} in practically every scenario, besides when the load is very high \cite{scheduler_performance_eval} \cite{5340336}. Therefore, both \ac{M-LWDF} and \ac{EXP/PF} seem worthwhile alternatives, but we choose the PF for this work.

\subsubsection*{Co-schedule users}
This step lists the users to be scheduled together until the next update to the schedule. The co-scheduling rule for a single-BS-panel operation is to add one UE layer at a time to the list, by order of \ac{UE} priority (computed in the previous step), if the best beams used for those layers are compatible with the previously added \ac{UE} layers. And we define as compatible beams when the BS-side beam, belonging to the \ac{GoB} is at least $\kappa$ beams apart, with $\kappa \in \mathbb{N}_0$. If $\kappa$ is 0, then all layers are accepted. If $\kappa = 1$, then the beams must be different - adjacent beams have a distance of 1, so are still used together. Beams located diagonally adjacent of the \ac{GoB} are considered to have a distance of 2, hence they may be co-scheduled when $\kappa \leq 2$. Figure \ref{fig:beam-rule} illustrates the beams that cannot be co-scheduled with certain values of $\kappa$, representing in filled blue circles as incompatible beams with respect to the orange one, and empty circles as compatible beams with the central orange beam. More generally, the beam distance is defined by the sum of absolute differences of the beam indices in the grid. Mathematically, the beamformers $\bm{w}_{i,j}$ and $\bm{w}'_{i',j'}$, having $(i,j)$ and $(i', j')$ as the GoB indices, respectively, are compatible if $|i-i'| + |j - j'| \geq \kappa$.
    
\image{SLS/mumimo-beam-rule.png}{Beam co-scheduling incompatibility distance.}{fig:beam-rule}{.5}

In this step there is space for more elaborate algorithms that attempt to choose different combinations of the best $N_{CSI}$ beams of each user, in an attempt to maximise the metrics we care about. Of course, if scheduling one more user considerably reduces the quality of the channel to many others, it is likely not worth doing.


\subsubsection*{Power Control}
Depending on the beamforming strategy, it may be necessary to scale down all precoders due to excessive power per antenna constraints. This, however, does not apply to our case because beam-steering beamformers always have uniform amplitude. Power control in the downlink is as simple as distributing the maximum total transmit power equally amongst the scheduled UEs and assigned PRBs.
    
\subsubsection*{MCS selection}
\label{sec:olla}
By now the transmit power to each user and the beam pairs are fixed. Therefore, we obtain an estimation of the SINR for each user, as done previously but with the new information on powers and beam pairs. And we obtain a MCS to be used for each transmission, according to the same process used in the throughput estimation.

The choice of which MCS to use for transmission has major impact in performance. Since choosing one MCS above what the channel quality allows can lead to excessive errors, while one lower than ideal will wastes resources. Factors such as the outdatedness of measurements complicate the process of choosing the correct MCS. We present a mechanism that adapts the MCS choice according with block errors. This procedure takes place every time a MCS is used, including in instantaneous throughput calculations.

It is a \ac{OLLA} mechanism \cite{olla_ref} and it is UE-specific. When a MCS is estimated, it is subsequently adjusted with the OLLA parameter. The OLLA parameter $\Delta_{OLLA}$ is initialised at zero and is updated in every TTI the given UE is scheduled. When a \ac{TB} is successfully transmitted, the OLLA parameter is updated with a step-size of $\gamma_{OLLA}$ according to Equation \eqref{eq:ola_update1_success} such that the \ac{BLER} long-term average converged to the target $BLER_0$. If the block is erroneous, Equation \eqref{eq:ola_update1_fail} is used instead.

\begin{equation} \label{eq:ola_update1_success}
    \Delta_{OLLA} = \Delta_{OLLA} + BLER_0 \times \gamma_{OLLA}
\end{equation}

\begin{equation} \label{eq:ola_update1_fail}
    \Delta_{OLLA} = \Delta_{OLLA} - (1 - BLER_0) \times \gamma_{OLLA}
\end{equation}

Observe the subtlety of the asymmetry in update. The term that multiplies the step size $\gamma_{OLLA}$ is much bigger in Equation \eqref{eq:ola_update1_fail} than in \eqref{eq:ola_update1_success}, since $BLER_0$ is usually 0.1 or smaller, depending on the QoS reliability requirements. It is a defensive approach, to take bigger steps towards more conservative MCSs when there are errors because it is always better to have some throughput than none. Contrarily, the progression to increasing the MCS is slower. 

The OLLA parameter adjusts the MCS choice by flipping an appropriately biased coin and adding either $\floor{\Delta_{OLLA}}$ or $\ceil{\Delta_{OLLA}}$ to the MCS index estimated in the previous step. An appropriately biased coin in this situation is a coin that selects to round down the OLLA parameter with a probability of $\ceil{\Delta_{OLLA}} - \Delta_{OLLA}$. This makes sense because $\Delta_{OLLA}$ is decreased when a block has errors, thus making more likely that the MCS is reduced when the link has worse quality than expected. When the block does not have errors, it makes it more likely to increase the MCS estimate, such that a good link condition can be taken advantage of to increase the bit rate. Note that this formulation still works as supposed for negative values, i.e. the OLLA mechanism works for increasing and decreasing the MCS.

\subsection{Transmission}

Here we obtain the outcomes of the realised transmissions. Firstly, we calculate the number of TBs in which the data to be transmitted in a given TTI is segmented. Secondly, the SINRs each UE experiences in each PRB are computed and then we present how these SINRs can be aggregated in something more easily useable to conclude on overall channel quality, an effective SINR. Finally, effective SINRs are probabilistically used to determine the success or failure of the transmitted transport blocks according with the MCS used for transmission and then the link quality adaptation mechanism is updated appropriately, as well as buffers and PF ratios, to be used in upcoming transmissions to assure a balanced operation of the system in line with the result of the transmission in the present TTI. As usual, the steps follow.

\subsubsection*{Transport Block Size Calculation}

To obtain the \ac{TBS}, essentially two ways have been modelled. The first is to consider the same number of TBs on every transmission, $N_{TB}$. Therefore the numbers of bits to be transmitted $N_{bits, bul}$ is divided equally over TBs and the size of each TB is the same, as shown in Equation \eqref{eq:tbs1}.


\begin{equation} \label{eq:tbs1}
    S_{TB} = \ceil{N_{bits, bul}/N_{TB}}    
\end{equation}

The second is to consider a maximum TBS $S_{TB, max}$, obtain $N_{TB}$ from Equation \eqref{eq:tbs2} and then use Equation \eqref{eq:tbs1}. 
\begin{equation} \label{eq:tbs2}
    N_{TB} = \ceil{N_{bits, bul}/S_{TB, max}}
\end{equation}

This such manner, $N_{TB}$ TBs are sent and the experienced bit rates depend on how many of them are delivered with no errors. If there are no errors, the bit rate computed in Equation \eqref{eq:bit rate} is achieved, otherwise only a fraction of that bit rate is achieved, corresponding to the successfully transmitted TBs over total TBs. One of the modelled methods is chosen by fixing either $N_{TB}$ or $S_{TB}$, respectively, for the first and second methods.

Another alternative way is to follow an extensive list of steps described in \cite{3gpp-codebooks}, making the Transport Block Size depend on the number of layers $\#\mathcal{L}_{bu}$ carrying the same QoS flow, modulation order $M$, code rate $R_c$, number of allocated PRBs $N_{PRB, bul}$ and transmission duration, which we assume to be always $T_{slot}$.

% link for TBS calculation: http://www.techplayon.com/5g-nr-transport-block-size-tbs-calculation/ 

\subsubsection*{Compute Realised SINR: A Multi-layer SINR Framework with Beamforming}
\label{sec:sinr_framework}

Although the rest of this chapter assumes simplifications for downlink  single-layer transmission, for future purposes we derive a general multi-layer framework that works for uplink as well. 

To accurately compute the SINR experienced during a transmission, we need to 
know the power received from each transmitter, for any scheduled \acs{UE}, taking into account the different channel responses in each \acs{PRB} of the assigned bandwidth.

Let $l$ be the layer that links a set of antennas in BS $b$ to a set of antennas in a UE $u$, with $P_{t, l}$ the total transmit power and $P_{r, l}$ is the received power in that layer, after combining the contributions of each receive antenna. Then, let $P_{r, ll'}$ be the power received by layer $l$ receiver using combiner $\bm{w}_{r, l}$, transmitted by layer $l'$ transmitter using precoder $\bm{w}_{t, l'}$, with $\bm{H}_{ll'}$ the channel matrix that connects the receiver and the transmitter. Equation \eqref{eq:general_rx_pow} shows how these quantities relate.

\begin{equation} \label{eq:general_rx_pow}
    P_{r, ll'} = P_{t, l'} \left| \bm{w}_{r, l} \cdot \bm{H}_{ll'} \cdot \bm{w}_{t, l'} \right|^2        
\end{equation}

The powers are scalars, $\bm{w}_{r, l}$ is a $1 \times N_r$ vector, $\bm{w}_{t, l'}$ is $N_t \times 1$ vector and $\bm{H}_{ll'}$ is a $N_r \times N_t$ matrix, where $N_t$ and $N_r$ are the number of antenna elements at the transmitter and receiver antenna arrays, respectively.

Knowing how to calculate this quantity we can compute the powers of all parts of the SINR expression on a PRB basis: the signal $P_s$, the intra-cell interference $P_{IaCI}$, the inter-cell interference $P_{IeCI}$, the inter-layer interference $P_{ILI}$ and the noise $P_N$. Here, the term cell refers to a panel. Using all these powers in Equation \eqref{eq:simple_SINR} we obtain the SINR of a specific layer $l$ in a given PRB. Subsequently we present equations for each quantity in the SINR expression, along with the rationale behind them. 


\begin{equation} \label{eq:simple_SINR}
    SINR = \frac{P_s}{P_{ILI} + P_{IaCI} + P_{IeCI} + P_N}
\end{equation}

Moreover, and to reiterate, all quantities mentioned in this section are time (TTI) and frequency (PRB) specific. These SINRs need to be posteriorly aggregated in an effective SINR for each transmission in the given TTI. We choose to omit the $i$ index to simplify notation, as we did with the TTI since this chapter is TTI-specific.

The received signal power $P_s$ is presented in Equation \eqref{eq:sig_pow}.

\begin{equation} \label{eq:sig_pow}
    P_s = P_{r, ll} 
\end{equation}

%ILI

In case of multi-layer transmission, other layers scheduled to/from the same UE may interfere among themselves. The power of inter-layer interference $P_{ILI}$ takes into account this interference by summing the interferences caused in layer $l$ by every other layer $l'$ scheduled between BS $b$ and UE $u$. This rational is condensed in Equation \eqref{eq:ili}, where $\mathcal{L}_{bu}$ is the set of layers scheduled between BS $b$ and UE $u$.

\begin{equation} \label{eq:ili}
    P_{ILI} = \sum_{\subalign{l&' \in \hspace{.05cm} \mathcal{L}_{bu} \\ &l' \neq l \\ \hspace{0.25cm} &}} P_{r, ll'} 
\end{equation}

% IaCI

Interference power contributions from the same cell/BS come from every transmission that takes place to other UEs in the same cell/served by the same BS. We take into account all those transmission in Equation \eqref{eq:iaci}, where $\mathcal{U}_{b}$ is the set of users served by BS $b$.

\begin{equation} \label{eq:iaci}
    P_{IaLI} = \mathlarger{\sum}_{\subalign{u' &\in \hspace{.05cm} \mathcal{U}_{b} \\ u'& \neq \hspace{.05cm} u}} \hspace{-0.1cm} \sum_{\subalign{l' &\in \hspace{.05cm} \mathcal{L}_{bu'} \\ \hspace{0.40cm} &}} \hspace{-0.1cm} P_{r, ll'} 
\end{equation}

% IeCI
Interference contributions from outside the cell come from all non-serving BSs, all UEs and in all layers. Equation \eqref{eq:ieci} represents this relation, where $\mathcal{B}$ is the set of all BS (or BS panels) in the system.

\begin{equation} \label{eq:ieci}
    P_{IeCI} = \mathlarger{\mathlarger{\sum}}_{\substack{b' \in \hspace{.05cm} \mathcal{B} \\ b' \neq b}} \ \mathlarger{\sum}_{\ u' \in \hspace{.05cm} \mathcal{U}_{b'}} \hspace{-0.2cm} \sum_{\subalign{&l' \in \hspace{.05cm} \mathcal{L}_{b'u'} \\ \hspace{0.25cm} &}} \hspace{-0.1cm} P_{r, ll'} 
\end{equation}

% PN
The noise power $P_N$ is computed according to Equation \ref{eq:noise}, using the bandwidth of a single PRB, which depends on the numerology as evidenced in Table \ref{tab:num}.

This framework is also applicable when several BS are jointly serving one user, or when one user is transmitting to several BS simultaneously, i.e. Distributed-MIMO (D-MIMO). This is true because we simply account for power contributions, abstracting from the content of the spatial streams.



\subsubsection*{Aggregate SINRs: Mutual Information Effective SINR Mapping}
\label{sec:miesm}

\acs{MI-ESM} is an SINR aggregation technique that allows us to attribute one SINR to a transmission where the quality of the channel varies across the transmission band, namely across PRBs. We choose this SINR mapping strategy because \cite{1656798, 4657235, 5982870, 6008103, miesm1} show that it unquestionably achieves very good results without the need of calibration for different MCSs. Equation \eqref{eq:miesm} sums how it works.

\begin{equation} \label{eq:miesm}
    SINR_{eff} = I_k^{-1} \left( \frac{1}{N} \sum_{i=1}^N I_k\left(SINR_i\right)\right)
\end{equation}

Above, $I_k$ is the mutual information function that for a given SINR and MCS (with $k$ bits per symbol) gives the bits of information that are conceivably extracted for a transmission with that SINR. For low SINRs, the mutual information is practically zero. As the SINR grows, the quantity of information bits extracted approaches $k$. Appendix \ref{ap:miesm} goes into further detail on the mutual information function works.  

Therefore, Equation \eqref{eq:miesm} obtains the mutual information achievable in each PRB, averages it and computes the SINR that would achieve that average information. Thus, the effective SINR is determined as the SINR that would yield this average mutual information if it were applied on all PRBs. 

\subsubsection*{Compute Block Errors}

Subsequently, with the effective SINR $SINR_{eff}$ and the MCS used for the transmission, we get the resultant $BLER$ from the correspondent MCS curve in Figure \ref{fig:blercurves}. Then we flip a \acs{BLER}-biased coin to determine whether each block was received well.


\subsubsection*{Update Link Adaptation, Buffers and Performance Indicators}

Firstly, the link adaptation mechanism is updated based on the block errors in accordance with Section \ref{sec:olla}. 

Then, the information that was successfully transmitted needs to be removed from the buffers. We model an ordered buffer where the information in one transport block has a direct mapping to IP packets. Therefore if that TB gets lost, those packets with information carried in the lost TB stay in the buffer.

This means that block errors may cause packets to arrive out of order. This phenomenon is represented in Figure \ref{fig:buf} where the size of a TB is set to the same size as a packet for illustration purposes. We see the bits in the transport blocks that did not arrive successfully are kept in the transmission buffer. Thus, if those bits are eventually successfully sent in the future, they would be out of order. Note that this is something common in packet networks. Successfully transmitted TBs get their share of packets removed from the buffers.


\image{Methodology/Radio Access/buffer.png}{Buffer state before and after a transmission, with $S_{TB} = S_{packet}$.}{fig:buf}{.28}

These modelling considerations make the system considerably more realistic compared to a pool-of-bits formulation where no packet has a specific latency budget. Since a packet is dropped when the time it has passed since it arrived in the buffer exceeds the latency budget for the radio link, such realistic modelling considerations increase the likelihood that a packet is discarded due to excessive delay, so the latencies supported in a given scenario are higher.

Finally, the throughputs are used in Equation \eqref{eq:pf2} to update the PF ratio.

\subsection*{Conclusion}

In this section we presented the required steps to perform data transmission. We started with TTI identification and slot format. Then, we modelled CSI acquisition and presented an intuitive way of creating a \ac{GoB}. Afterwards, in the user scheduling steps, we addressed SINR estimation, instantaneous throughput calculation from an SINR, user priority calculation, user co-scheduling, power control and finally the selection of MCS for the transmission, adjusted with a link adaptation algorithm.

Finally, we simulate a data transmission, where we introduced calculations on the number and size of TBs. Then we presented a flexible SINR framework and a broadly accepted SINR aggregation algorithm, respectively, to compute the SINR each UE experienced in a given transmission in each PRB, and to aggregate those SINRs in one effective SINR that describes the quality of the transmission. Lastly, we used that SINR to determine the block errors, which are in turn used to adapt the link adaptation parameter, to remove the TB contents from the buffer in case it is successfully transmitted and to update the schedulers PF ratios.

In the next section we simulate single and multi-user scenarios and assess the relations between several parameters described in this section. 

